package egon

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
)

// Package represents the source file representation of a template.
// Note that it's on its way out, in favor of this functionality being included
// in Template.
type Package struct {
	Template *Template
}

// Write writes out the package header and templates to a writer.
func (p *Package) Write() error {
	f, err := os.Create(p.Template.SourceFile())
	defer f.Close()

	if err != nil {
		return err
	}

	if err := p.writeHeader(f); err != nil {
		return err
	}

	if err := p.Template.Write(f); err != nil {
		return fmt.Errorf("template: %s: %s", p.Template.Path, err)
	}

	return nil
}

// Writes the package name and consolidated header blocks.
func (p *Package) writeHeader(w io.Writer) error {
	name, err := p.Template.PackageName()
	if err != nil {
		return err
	}

	// Write naive header first.
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "package %s\n", name)
	for _, b := range p.Template.headerBlocks() {
		b.write(&buf)
	}

	// Parse header into Go AST.
	f, err := parser.ParseFile(token.NewFileSet(), "ego.go", buf.String(), parser.ImportsOnly)
	if err != nil {
		fmt.Println(buf.String())
		return fmt.Errorf("writeHeader: %s", err)
	}

	// Reset buffer.
	buf.Reset()

	// Add note that the file is auto-generated
	fmt.Fprintf(&buf, "// Generated by egon.\n")
	fmt.Fprintf(&buf, "// ðŸš«Edit at your own risk.\n\n")

	fmt.Fprintf(&buf, "package %s\n", name)

	// Write deduped imports.
	var decls = map[string]bool{`:"fmt"`: true, `:"io"`: true}
	fmt.Fprint(&buf, "import (\n")
	if (Config.GenerateView) {
		fmt.Fprintln(&buf, `"github.com/SlinSo/egon"`)
	}
	if p.Template.hasFmtPrintBlock() {
		fmt.Fprintln(&buf, `"fmt"`)
	}
	if p.Template.hasItoaPrintBlock() {
		fmt.Fprintln(&buf, `"strconv"`)
	}
	if p.Template.hasEscapedPrintBlock() {
		fmt.Fprintln(&buf, `"html"`)
		decls["html"] = true
	}
	fmt.Fprintln(&buf, `"io"`)

	for _, d := range f.Decls {
		d, ok := d.(*ast.GenDecl)
		if !ok || d.Tok != token.IMPORT {
			continue
		}

		for _, s := range d.Specs {
			s := s.(*ast.ImportSpec)
			var id string
			if s.Name != nil {
				id = s.Name.Name
			}
			id += ":" + s.Path.Value

			// Ignore any imports which have already been imported.
			if decls[id] {
				continue
			}
			decls[id] = true

			// Otherwise write it.
			if s.Name == nil {
				fmt.Fprintf(&buf, "%s\n", s.Path.Value)
			} else {
				fmt.Fprintf(&buf, "%s %s\n", s.Name.Name, s.Path.Value)
			}
		}
	}
	fmt.Fprint(&buf, ")\n")

	// Write out to writer.
	buf.WriteTo(w)

	return nil
}
